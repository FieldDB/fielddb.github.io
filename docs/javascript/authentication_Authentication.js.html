<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>authentication/Authentication.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Activities.html">Activities</a></li><li><a href="Activity.html">Activity</a></li><li><a href="App.html">App</a></li><li><a href="AppRouter.html">AppRouter</a><ul class='methods'><li data-type='method'><a href="AppRouter.html#renderDashboardOrNot">renderDashboardOrNot</a></li><li data-type='method'><a href="AppRouter.html#showAllData">showAllData</a></li><li data-type='method'><a href="AppRouter.html#showAllDataInSession">showAllDataInSession</a></li><li data-type='method'><a href="AppRouter.html#showDashboard">showDashboard</a></li><li data-type='method'><a href="AppRouter.html#showEmbeddedCorpus">showEmbeddedCorpus</a></li><li data-type='method'><a href="AppRouter.html#showEmbeddedSearch">showEmbeddedSearch</a></li><li data-type='method'><a href="AppRouter.html#showEmbeddedSession">showEmbeddedSession</a></li><li data-type='method'><a href="AppRouter.html#showFullscreenCorpus">showFullscreenCorpus</a></li><li data-type='method'><a href="AppRouter.html#showFullscreenDataList">showFullscreenDataList</a></li><li data-type='method'><a href="AppRouter.html#showFullscreenSearch">showFullscreenSearch</a></li><li data-type='method'><a href="AppRouter.html#showFullscreenSession">showFullscreenSession</a></li><li data-type='method'><a href="AppRouter.html#showFullscreenUser">showFullscreenUser</a></li></ul></li><li><a href="AudioPlayer.html">AudioPlayer</a></li><li><a href="AudioVideo.html">AudioVideo</a></li><li><a href="AudioVideoRecorder.html">AudioVideoRecorder</a></li><li><a href="AudioVideos.html">AudioVideos</a></li><li><a href="Authentication.html">Authentication</a></li><li><a href="Collection.html">Collection</a></li><li><a href="Comment.html">Comment</a></li><li><a href="Comments.html">Comments</a></li><li><a href="ComputationalLinguisticsDatum.html">ComputationalLinguisticsDatum</a></li><li><a href="Confidential.html">Confidential</a></li><li><a href="Connection.html">Connection</a><ul class='methods'><li data-type='method'><a href="Connection.html#.validateIdentifier">validateIdentifier</a></li></ul></li><li><a href="Consultant.html">Consultant</a></li><li><a href="Consultants.html">Consultants</a></li><li><a href="Contexts.html">Contexts</a></li><li><a href="ContextualizableObject.html">ContextualizableObject</a></li><li><a href="Contextualizer.html">Contextualizer</a></li><li><a href="Conversation.html">Conversation</a><ul class='methods'><li data-type='method'><a href="Conversation.html#saveAndInterConnectInApp">saveAndInterConnectInApp</a></li><li data-type='method'><a href="Conversation.html#setAsCurrentConversation">setAsCurrentConversation</a></li></ul></li><li><a href="Conversations.html">Conversations</a></li><li><a href="Corpus.html">Corpus</a></li><li><a href="CorpusMask.html">CorpusMask</a></li><li><a href="DataList.html">DataList</a></li><li><a href="DataLists.html">DataLists</a></li><li><a href="Datum.html">Datum</a></li><li><a href="DatumField.html">DatumField</a></li><li><a href="DatumFields.html">DatumFields</a></li><li><a href="Datums.html">Datums</a></li><li><a href="DatumState.html">DatumState</a></li><li><a href="DatumStates.html">DatumStates</a></li><li><a href="DatumTag.html">DatumTag</a></li><li><a href="DatumTags.html">DatumTags</a></li><li><a href="DocumentCollection.html">DocumentCollection</a></li><li><a href="ELanguages.html">ELanguages</a></li><li><a href="ExperimentDataList.html">ExperimentDataList</a></li><li><a href="Export.html">Export</a></li><li><a href="FieldDBObject.html">FieldDBObject</a><ul class='methods'><li data-type='method'><a href="FieldDBObject.html#.uuidGenerator">uuidGenerator</a></li></ul></li><li><a href="GitImport.html">GitImport</a></li><li><a href="Glosser.html">Glosser</a><ul class='methods'><li data-type='method'><a href="Glosser.html#.calculateAllAlternativeCombinations">calculateAllAlternativeCombinations</a></li><li data-type='method'><a href="Glosser.html#.removeRedundantCopies">removeRedundantCopies</a></li><li data-type='method'><a href="Glosser.html#.sortAlternatesByLessSegmentation">sortAlternatesByLessSegmentation</a></li><li data-type='method'><a href="Glosser.html#.sortAlternatesByMoreSegmentation">sortAlternatesByMoreSegmentation</a></li></ul></li><li><a href="HotKey.html">HotKey</a></li><li><a href="HotKeys.html">HotKeys</a></li><li><a href="HTML5Audio.html">HTML5Audio</a></li><li><a href="Image.html">Image</a></li><li><a href="Images.html">Images</a></li><li><a href="Import.html">Import</a></li><li><a href="LanguageDatum.html">LanguageDatum</a></li><li><a href="Lexicon.html">Lexicon</a></li><li><a href="LexiconNode.html">LexiconNode</a></li><li><a href="Participant.html">Participant</a></li><li><a href="Permission.html">Permission</a></li><li><a href="Permissions.html">Permissions</a></li><li><a href="PsycholinguisticsApp.html">PsycholinguisticsApp</a></li><li><a href="ReportBot.html">ReportBot</a><ul class='methods'><li data-type='method'><a href="ReportBot.html#schedule">schedule</a></li></ul></li><li><a href="Response.html">Response</a></li><li><a href="Search.html">Search</a></li><li><a href="Session.html">Session</a></li><li><a href="Sessions.html">Sessions</a></li><li><a href="Speaker.html">Speaker</a></li><li><a href="Stimulus.html">Stimulus</a></li><li><a href="SubExperimentDataList.html">SubExperimentDataList</a></li><li><a href="Team.html">Team</a></li><li><a href="UnicodeSymbol.html">UnicodeSymbol</a></li><li><a href="UnicodeSymbols.html">UnicodeSymbols</a></li><li><a href="User.html">User</a></li><li><a href="UserApp.html">UserApp</a></li><li><a href="UserMask.html">UserMask</a></li><li><a href="UserPreference.html">UserPreference</a></li><li><a href="UserRouter.html">UserRouter</a><ul class='methods'><li data-type='method'><a href="UserRouter.html#showCorpusDashboard">showCorpusDashboard</a></li><li data-type='method'><a href="UserRouter.html#showDashboard">showDashboard</a></li><li data-type='method'><a href="UserRouter.html#showFullscreenUser">showFullscreenUser</a></li></ul></li><li><a href="Users.html">Users</a></li><li>{String: Exercise}</li></ul><h3>Modules</h3><ul><li><a href="module-FieldDB.html">FieldDB</a></li></ul><h3>Global</h3><ul><li><a href="global.html#add">add</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#debugMode">debugMode</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#getMD5ForFile">getMD5ForFile</a></li><li><a href="global.html#getSanitizedDotNotationKey">getSanitizedDotNotationKey</a></li><li><a href="global.html#LexiconFactory">LexiconFactory</a></li><li><a href="global.html#sanitizeStringForFileSystem">sanitizeStringForFileSystem</a></li><li><a href="global.html#sanitizeStringForPrimaryKey">sanitizeStringForPrimaryKey</a></li><li><a href="global.html#showDiffs">showDiffs</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">authentication/Authentication.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/* globals window, document */

var FieldDBObject = require("./../FieldDBObject").FieldDBObject;
var Database = require("./../corpus/Database").Database;
var CORS = Database.CORS;
// var UserMask = require("./../user/UserMask").UserMask;
var User = require("./../user/User").User;
var Confidential = require("./../confidentiality_encryption/Confidential").Confidential;
var Q = require("q");
var Connection = require("./../corpus/Connection").Connection;

// var md5 = require("md5");
var bcrypt = require("bcrypt-nodejs");
// console.log(bcrypt.hashSync("phoneme", "$2a$10$UsUudKMbgfBQzn5SDYWyFe"));

/**
 * @class The Authentication Model handles login and logout and
 *        authentication locally or remotely. *
 *
 * @property {User} user The user is a User object (User, Bot or Consultant)
 *           which is logged in and viewing the app with that user's
 *           perspective. To check whether some data is
 *           public/viewable/editable the app.user should be used to verify
 *           the permissions. If no user is logged in a special user
 *           "public" is logged in and used to calculate permissions.
 *
 * @extends FieldDBObject
 * @tutorial tests/authentication/AuthenticationTest.js
 */
var Authentication = function Authentication(options) {
  if (!this._fieldDBtype) {
    this._fieldDBtype = "Authentication";
  }
  this.debug("Constructing a Authentication " + options);

  var self = this;

  this.loading = true;
  var deferred = new Q.defer();
  this.resumingSessionPromise = deferred.promise;
  Database.prototype.resumeAuthenticationSession().then(function(user) {
    CORS.application = FieldDBObject.application;

    self.loading = false;
    self.debug(user);
    self.user = user;
    self.user.fetch();
    if (self.user._rev) {
      self.user.authenticated = true;
      self.dispatchEvent("authenticateSuccess");
      deferred.resolve(self.user);
    } else {
      self.user.authenticated = false;
      self.dispatchEvent("authenticateMustConfirmIdentity");
      deferred.reject({
        status: 401,
        userFriendlyErrors: ["Please login."]
      });
    }

    // if (sessionInfo.ok &amp;&amp; sessionInfo.userCtx.name) {
    //   selfauthentication.user.username = sessionInfo.userCtx.name;
    //   selfauthentication.user.roles = sessionInfo.userCtx.roles;
    //   processUserDetails(selfauthentication.user);
    // } else {
    //   if (window.location.pathname.indexOf("welcome") &lt; 0 &amp;&amp; window.location.pathname.indexOf("bienvenu") &lt; 0) {
    //     $scope.$apply(function() {
    //       // $location.path(selfbasePathname + "/#/welcome/", false);
    //       window.location.replace(selfbasePathname + "/#/welcome");
    //     });
    //   }
    // }
    return self.user;
  }, function(error) {
    // Wait and see if a login call is coming...
    Q.nextTick(function() {
      if (self.loggingIn) {
        deferred.resolve(self.user);
        return;
      }
      self.loading = false;
      self.warn("Unable to resume login " + error.userFriendlyErrors.join(" "));
      if (error.status === 401) {
        self.dispatchEvent("authenticateMustConfirmIdentity");
      } else {
        // error.userFriendlyErrors = ["Unable to resume session, are you sure you're not offline?"];
        self.error = error.userFriendlyErrors.join(" ");
        // self.dispatchEvent("authenticateMustConfirmIdentity");
      }
      self.render();
      deferred.reject(error);
    });

    return error;
  }).fail(function(error) {
    console.error(error.stack, self);
    deferred.reject(error);
    return error;
  });

  FieldDBObject.apply(this, arguments);
};

Authentication.prototype = Object.create(FieldDBObject.prototype, /** @lends Authentication.prototype */ {
  constructor: {
    value: Authentication
  },

  // Internal models: used by the parse function
  INTERNAL_MODELS: {
    value: {
      user: User,
      confidential: Confidential
    }
  },

  dispatchEvent: {
    value: function(eventChannelName, reason) {
      try {
        if (this.eventDispatcher &amp;&amp; typeof this.eventDispatcher.trigger === "function") {
          this.eventDispatcher.trigger(eventChannelName, reason);
        } else {
          this.eventDispatcher = this.eventDispatcher || document;
          var event = this.eventDispatcher.createEvent("Event");
          event.initEvent(eventChannelName, true, true);
          this.eventDispatcher.dispatchEvent(event);
        }
      } catch (e) {
        this.warn("Cant dispatch event " + eventChannelName + " the document element isn't available.");
        this.debug(" error ", e);
      }
    }
  },

  /**
   * Contacts local or remote server to verify the username and password
   * provided in the user object. Upon success, calls the callback with the
   * user.
   *
   * @param user A user object to verify against the authentication database
   * @param callback A callback to call upon sucess.
   */
  login: {
    value: function(loginDetails) {
      var deferred = Q.defer(),
        self = this;

      if (this.whenLoggedIn){
        return this.whenLoggedIn;
      }
      this.whenLoggedIn = deferred.promise;

      var dataToPost = {};
      dataToPost.username = loginDetails.username;
      dataToPost.password = loginDetails.password;
      dataToPost.authUrl = loginDetails.authUrl;
      dataToPost.connection = loginDetails.connection;

      if (!loginDetails.syncUserDetails) {
      //if the same user is re-authenticating, include their details to sync to the server.
        var tempUser = new User(loginDetails);
        tempUser.fetch();
        if (tempUser._rev &amp;&amp; tempUser.username !== "public" &amp;&amp; !tempUser.fetching &amp;&amp; !tempUser.loading &amp;&amp; tempUser.lastSyncWithServer) {
          dataToPost.syncDetails = "true";
          dataToPost.syncUserDetails = tempUser.toJSON();
          tempUser.warn("Backing up tempUser details", dataToPost.syncUserDetails);
          delete dataToPost.syncUserDetails._rev;
          //TODO what if they log out, when they have change to their private data that hasnt been pushed to the server,
          //the server will overwrite their details.
          //should we automatically check here, or should we make htem a button
          //when they are authetnticated to test if they ahve lost their prefs etc?
        }
      }

      this.error = "";
      this.status = "";
      this.loading = this.loggingIn = true;

      var handleFailedLogin = function(error) {
        self.loading = false;
        if (self.user) {
          self.user.authenticated = false;
        }
        if (!error || !error.userFriendlyErrors) {
          error.userFriendlyErrors = ["Unknown error. Please report this 2456."];
          self.dispatchEvent("authenticateMustConfirmIdentity");
        } else {
          self.dispatchEvent("authenticateFail", error);
        }
        error.details = loginDetails;
        self.warn("Logging in failed: " + error.status, error.userFriendlyErrors);
        self.error = error.userFriendlyErrors.join(" ");
        deferred.reject(error);

        delete self.whenLoggedIn;
        delete self.loggingIn;
      };

      self.resumingSessionPromise = deferred.promise;
      Database.prototype.login(dataToPost)
        .then(function(userDetails) {

            if (!userDetails) {
              self.loading = false;
              self.dispatchEvent("authenticateMustConfirmIdentity");
              deferred.reject({
                details: loginDetails,
                status: 500,
                userFriendlyErrors: ["Unknown error. Please report this 2391."]
              });
              return;
            }

            try {
              self.user = userDetails;
              self.user.lastSyncWithServer = Date.now();
            } catch (e) {
              console.warn("There was a problem assigning the user. ", e);
            }
            self.authenticateWithAllCorpusServers(loginDetails).then(function() {
              self.loading = false;
              self.user.authenticated = true;
              self.dispatchEvent("authenticateSuccess");
              deferred.resolve(self.user);
            }, function() {
              self.loading = false;
              deferred.resolve(self.user);
            }).fail(function(error) {
              self.loading = false;
              console.error(error.stack, self);
              deferred.resolve(self.user);
            });

            delete self.loggingIn;
          }, //end successful login
          handleFailedLogin)
        .fail(function(error) {
          delete self.loggingIn;
          console.error(error.stack, self);
          handleFailedLogin(error);
        });

      return this.whenLoggedIn;
    }
  },

  confirmIdentity: {
    value: function(loginDetails) {
      var deferred = Q.defer(),
        self = this;

      if (!loginDetails || !loginDetails.password) {
        Q.nextTick(function() {
          deferred.reject({
            userFriendlyErrors: ["You must enter your password to confirm your identity."]
          });
        });
        return deferred.promise;
      }

      if (!this.user.username ||
        !this.user.authenticated ||
        !this.user.lastSyncWithServer ||
        !this.user.hash ||
        !this.user.salt) {
        Q.nextTick(function() {
          deferred.reject({
            userFriendlyErrors: "You must login first."
          });
        });
        return deferred.promise;
      }

      try {
        loginDetails.password = (loginDetails.password + "").trim();
        bcrypt.compare(loginDetails.password, self.user.hash, function(err, confirmed) {
          if (confirmed) {
            loginDetails.info = ["Verified offline."];
            deferred.resolve(loginDetails);
          } else {
            loginDetails.error = err;
            if (err) {
              loginDetails.userFriendlyErrors = ["This app has errored while trying to confirm your identity. Please report this 2892346."];
            } else {
              loginDetails.userFriendlyErrors = ["Sorry, this doesn't appear to be you."];
            }
            deferred.reject(loginDetails);
          }
        });
      } catch (e) {
        loginDetails.userFriendlyErrors = ["This app has errored while trying to confirm your identity. Please report this 289234."];
        deferred.reject(loginDetails);
      }

      return deferred.promise;
    }
  },

  authenticateWithAllCorpusServers: {
    value: function(loginDetails) {
      var deferred = Q.defer(),
        self = this,
        corpusServersWhichHouseUsersCorpora = [],
        promises = [];

      if ((!this.user.corpora || this.user.corpora.length === 0) &amp;&amp; !loginDetails.connection) {
        Q.nextTick(function() {
          self.bug("You don't have access to any corpora. This is strange.");
          deferred.resolve(self.user);
        });
        return deferred.promise;
      }

      if (loginDetails.connection) {
        corpusServersWhichHouseUsersCorpora.push(loginDetails.connection.corpusUrl);
      }

      self.debug("loginDetails.connection", loginDetails.connection);
      this.user.corpora.map(function(connection) {
        var addThisServerIfNotAlreadyThere = function(url) {
          var couchdbSessionUrl = url.replace(connection.dbname, "_session");
          if (corpusServersWhichHouseUsersCorpora.indexOf(couchdbSessionUrl) === -1) {
            corpusServersWhichHouseUsersCorpora.push(couchdbSessionUrl);
          }

          //old logic from database.
          // if (!self.dbname &amp;&amp; corpusServersWhichHouseUsersCorpora.indexOf(couchdbSessionUrl) === -1) {
          //   corpusServersWhichHouseUsersCorpora.push(couchdbSessionUrl);
          // } else if (self.dbname &amp;&amp; connection.dbname === self.dbname &amp;&amp; corpusServersWhichHouseUsersCorpora.indexOf(couchdbSessionUrl) === -1) {
          //   corpusServersWhichHouseUsersCorpora.push(couchdbSessionUrl);
          // }
        };

        if (connection.corpusUrls) {
          connection.corpusUrls.map(addThisServerIfNotAlreadyThere);
        } else {
          addThisServerIfNotAlreadyThere(connection.corpusUrl);
        }
      });

      if (corpusServersWhichHouseUsersCorpora.length &lt; 1) {
        this.bug("You don't have access to any corpora. This is strange.");
      }
      this.debug("Requesting session token for all corpora user has access to.");
      this.user.roles = [];
      for (var corpusUrlIndex = 0; corpusUrlIndex &lt; corpusServersWhichHouseUsersCorpora.length; corpusUrlIndex++) {
        promises.push(Database.prototype.login({
          authUrl: corpusServersWhichHouseUsersCorpora[corpusUrlIndex],
          name: this.user.username,
          password: loginDetails.password
        }));
      }

      Q.allSettled(promises).then(function(results) {
        var anySucceeded = false;
        var errorReason = {};
        var allRoles = [];
        results.map(function(result) {
          self.debug("some roles", result);
          if (result.state === "fulfilled" &amp;&amp; result.value &amp;&amp; result.value.roles) {
            allRoles = allRoles.concat(result.value.roles);
            anySucceeded = true;
          } else {
            self.debug("Failed to login to one of the users's corpus servers ", result);
            if (result.reason &amp;&amp; result.reason.status !== undefined) {
              errorReason.status = result.reason.status;
            }
            if (result.reason &amp;&amp; result.reason.userFriendlyErrors) {
              errorReason.userFriendlyErrors = result.reason.userFriendlyErrors;
            }
            if (result.reason &amp;&amp; result.reason.details) {
              errorReason.details = result.reason.details;
            }
          }
          self.debug("some roles", allRoles);
        });
        var roles = {};
        self.user.roles = [];
        allRoles.map(function(role) {
          if (role &amp;&amp; !roles[role]) {
            roles[role] = 1;
            self.user.roles.push(role);
          }
        });

        if (anySucceeded) {
          deferred.resolve(self.user);
        } else {
          errorReason.all = results;
          deferred.reject(errorReason);
        }
      });

      // .then(function(sessionInfo) {
      //   // self.debug(sessionInfo);
      //   result.user.roles = sessionInfo.roles;
      //   deferred.resolve(result.user);
      // }, function() {
      //   self.debug("Failed to login ");
      //   deferred.reject("Something is wrong.");
      // });
      return deferred.promise;
    }
  },

  register: {
    value: function(options) {
      var self = this,
        deferred = Q.defer();

      this.loading = true;
      Database.prototype.register(options).then(function(userDetails) {
        self.debug("registration succeeeded, waiting to login ", userDetails);

        // self.user = userDetails;

        var waitTime = 1000;
        var loopExponentialDecayLogin = function(options) {
          self.login(options).
          then(function(results) {

            self.debug("    login after registration is complete " + waitTime, results);
            deferred.resolve(results);

          }, function(error) {
            waitTime = waitTime * 2;
            error.details = options;
            if (waitTime > 60 * 1000) {
              deferred.reject(error);
            } else {
              self.debug("    waiting to login " + waitTime, error);
              self.loading = true;
              setTimeout(function() {
                loopExponentialDecayLogin(options);
              }, waitTime);
            }
          }).fail(
            function(error) {
              console.error(error.stack, self);
              deferred.reject(error);
            });
        };
        loopExponentialDecayLogin(options);

      }, function(error) {
        self.loading = false;
        self.debug("registration failed ", error);
        deferred.reject(error);
      });

      return deferred.promise;
    }
  },

  logout: {
    value: function(options) {
      var self = this;
      this.loading = true;

      this.save();
      options = options || {};
      return Database.prototype.logout(options.url).then(function() {
        self.dispatchEvent("logout");
        self.loading = false;

        if (options &amp;&amp; !options.letClientHandleCleanUp) {
          self.warn("Reloading the page");
          try {
            window.location.reload();
          } catch (e) {
            self.debug("Window is undefined", e);
          }
        }

      });
    }
  },

  /**
   * This function parses the server response and injects it into the authentication's user public and user private
   *
   */
  user: {
    get: function() {
      return this._user;
    },
    set: function(value) {
      if (!value) {
        return;
      }
      var overwriteOrNot;

      this.debug("setting user");
      // if (!(value instanceof User)) {
      //   value = new User(value);
      // }

      if (this._user &amp;&amp; this._user.username === value.username) {
        if (!this._user.rev) {
          this.debug("Fetching the user's full details");
          this._user.fetch();
        }
        this.debug("Merging the user", this._user, value);
        if (!(value instanceof User)) {
          value = new User(value);
        }
        if (!this._user._rev) {
          overwriteOrNot = "overwrite";
        }
        this._user.merge("self", value, overwriteOrNot);
      } else {
        if (!(value instanceof User)) {
          value = new User(value);
        }
        this.debug("Setting the user");
        this._user = value;
      }

      var self = this;
      this._user.save().then(function() {
        self.debug("Saved user ");
      });
      this._user.render();

    }
  },

  save: {
    value: function() {
      return this.user.save();
    }
  },

  /**
   * This function uses the quick authentication view to get the user's
   * password and authenticate them. The authenticate process brings down the
   * user from the server, and also gets their sesson token from couchdb
   * before calling the callback.
   *
   * If there is no quick authentication view it takes them either to the user
   * page (in the ChromeApp) or the public user page (in a couchapp) where
   * they dont have to have a corpus token to see the data, and log in
   *
   * @param callback
   *          a success callback which is called once the user has been backed
   *          up to the server, and their couchdb session token is ready to be
   *          used to contact the database.
   * @param corpusPouchName
   *          an optional corpus pouch name to redirect the user to if they
   *          end up geting kicked out of the corpus page
   */
  syncUserWithServer: {
    value: function() {
      var self = this;
      this.todo("will this return a promise.");
      return this.renderQuickAuthentication()
        .then(function(userinfo) {
          self.login(userinfo);
        })
        .fail(function(error) {
          console.error(error.stack, self);
        });
    }
  },

  newCorpus: {
    value: function(details) {
      var deferred = Q.defer(),
        self = this;

      Q.nextTick(function() {

        if (!details) {
          deferred.reject({
            details: details,
            userFriendlyErrors: ["This application has errored, please contact us."],
            status: 412
          });
          return;
        }

        details.authUrl = Database.prototype.deduceAuthUrl(details.authUrl);

        if (!details.username) {
          deferred.reject({
            details: details,
            userFriendlyErrors: ["Please supply a username."],
            status: 412
          });
          return;
        }
        if (!details.password) {
          deferred.reject({
            details: details,
            userFriendlyErrors: ["You must enter your password to prove that that this is you."],
            status: 412
          });
          return;
        }
        details.title = details.title || details.newCorpusTitle;
        details.newCorpusTitle = details.title;

        if (!details.title) {
          deferred.reject({
            details: details,
            userFriendlyErrors: ["Please supply a title for your new corpus."],
            status: 412
          });
          return;
        }

        var validateUsername = Connection.validateUsername(details.username);
        if (validateUsername.changes.length > 0) {
          details.username = validateUsername.identifier;
          self.warn(" Invalid username ", validateUsername.changes.join("\n "));
          deferred.reject({
            error: validateUsername,
            userFriendlyErrors: validateUsername.changes,
            status: 412
          });
          return;
        }

        CORS.makeCORSRequest({
          type: "POST",
          dataType: "json",
          url: details.authUrl + "/newcorpus",
          data: details
        }).then(function(authserverResult) {
            self.debug(authserverResult);
            if (authserverResult.corpus) {
              self.user.corpora.shift(authserverResult.corpus);
              self.save();
            } else {
              if (authserverResult.status > 0 &amp;&amp; authserverResult.status &lt; 400 &amp;&amp; self.user.corpora &amp;&amp; typeof self.user.corpora.find === "function") {
                authserverResult.corpus = self.user.corpora.find("dbname", Connection.validateIdentifier(details.newCorpusTitle).identifier, "fuzzy");
                if (authserverResult.corpus &amp;&amp; authserverResult.corpus.length > 0) {
                  authserverResult.corpus = authserverResult.corpus[0];
                }
              }
            }
            deferred.resolve(authserverResult.corpus);
          },
          function(reason) {
            reason = reason || {};
            reason.details = details;
            reason.userFriendlyErrors = reason.userFriendlyErrors || ["Unknown error, please report this."];
            self.debug(reason);
            deferred.reject(reason);
          }).fail(
          function(error) {
            console.error(error.stack, self);
            deferred.reject(error);
          });
      });
      return deferred.promise;
    }
  },

  toJSON: {
    value: function(includeEvenEmptyAttributes, removeEmptyAttributes) {
      this.debug("Customizing toJSON ", includeEvenEmptyAttributes, removeEmptyAttributes);

      var attributesNotToJsonify = ["resumingSessionPromise", "eventDispatcher"];
      var json = FieldDBObject.prototype.toJSON.apply(this, [includeEvenEmptyAttributes, removeEmptyAttributes, attributesNotToJsonify]);

      this.debug(json);
      return json;
    }
  }

});

exports.Authentication = Authentication;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Sat Mar 18 2017 20:02:56 GMT-0400 (EDT) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
